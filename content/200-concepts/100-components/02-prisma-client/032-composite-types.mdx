---
title: 'Composite types'
metaTitle: 'Composite types'
metaDescription: 'Composite types'
tocDepth: 2
preview: true
---

<TopBlock>

<Admonition type="info">

Composite types are available in Preview in versions `3.10.0` and later.

</Admonition>

<Admonition type="warning">

Composite types are currently only available on MongoDB.

</Admonition>

[Composite types](/concepts/components/prisma-schema/data-model#defining-composite-types), known as [embedded documents](https://docs.mongodb.com/manual/core/data-model-design/#std-label-data-modeling-embedding) in MongoDB, allow you to embed records within other records.

This page explains how to create, update, delete and filter composite types in the Prisma Client.

</TopBlock>

## Example schema

We’ll use this schema for the examples that follow:

```prisma file=schema.prisma
model Product {
  id     String  @id
  name   String
  price  Decimal
  colors Color[]
  sizes  Size[]
  photos Photo[]
}

model Order {
  id              String   @id
  product         Product
  color           Color
  size            Size
  shippingAddress Address
  billingAddress  Address?
}

enum Color {
  Red
  Green
  Blue
}

enum Size {
	Small
	Medium
	Large
  XLarge
}

type Photo {
  height Int
  width  Int
  url    String
}

type Address {
  street String
  city   String
  zip    String
}
```

In this schema, the `Product` model has a `Photo[]` composite type, and the `Order` model has two embedded `Address` types. The `shippingAddress` is required, but the `billingAddress` is optional.

## Considerations when using composite types

There are currently some limitations when using composite types in the Prisma Client:

- [`findUnique`](/reference/api-reference/prisma-client-reference#findunique) can't filter on composite types
- [`aggregrate`](/concepts/components/prisma-client/aggregation-grouping-summarizing#aggregate), [`groupBy`](/concepts/components/prisma-client/aggregation-grouping-summarizing#group-by), [`count`](/concepts/components/prisma-client/aggregation-grouping-summarizing#count) don’t support embedded operations.

## Enabling composite types with the MongoDB Preview feature

To use composite types with MongoDB, you will need to enable the `mongoDb` Preview feature in your `schema.prisma` file:

```prisma file="schema.prisma"
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["mongoDb"]
}
```

## Creating composite types with `create` and `createMany`

Composite types can be created within a `create` or `createMany` method using the new `set` method. For example, you can use `set` within `create` to create an `Address` composite type inside an `Order`:

```ts

const order = await prisma.order.create({
  data: {
    // Normal relation
    product: { connect: { ... } }
    color: "Red",
    size: "Large",
    // Composite type
    shippingAddress: {
      set: {
        street: "1084 Candycane Lane",
        city: "Silverlake",
        zip: "84323"
      }
    }
  }
})

```

You can also use a shorthand notation where you leave out the `set` and specify just the fields that you want to create:

```ts

const order = await prisma.order.create({
  data: {
    // Normal relation
    product: { connect: { ... } }
    color: "Red",
    size: "Large",
    // Composite type
    shippingAddress: {
      {
        street: "1084 Candycane Lane",
        city: "Silverlake",
        zip: "84323"
      }
    }
  }
})

```

For an optional type, like the `billingAddress`, you can also set the value to `null`:

```ts
const order = await prisma.order.create({
  data: {
    // Embedded optional type, set to null
    billingAddress: {
      set: null,
    },
  },
})
```

To model the case where an `product` contains a list of multiple `photos`, you can `set` multiple composite types at once:

```ts
const product = prisma.product.create({
  data: {
    name: "Forest Runners",
    price: 59.99
    // Scalar lists that we already support
    colors: ["Red", "Green"],
    sizes: ["Small", "Medium", "Large"]
    // New composite type
    photos: {
      set: [
				{ height: 100, width: 200, url: "1.jpg" },
				{ height: 100, width: 200, url: "2.jpg" }
      ]
    }
  }
})
```

These operations also work within the `createMany` method. For example, you can create multiple `product`s which each contain a list of `photos`:

```ts

const product = prisma.product.createMany({
  data: [
    {
      name: "Forest Runners",
      price: 59.99
      // Scalar lists that we already support
      colors: ["Red", "Green"],
      sizes: ["Small", "Medium", "Large"]
      // New Composite type
      photos: {
        set: [
				  { height: 100, width: 200, url: "1.jpg" },
				  { height: 100, width: 200, url: "2.jpg" }
        ]
      }
    },
    {
      name: "Alpine Blazers",
      price: 85.99
      // Scalar lists that we already support
      colors: ["Blue", "Red"],
      sizes: ["Large", "XLarge"]
      // New composite type
      photos: {
        set: [
				  { height: 100, width: 200, url: "1.jpg" },
				  { height: 150, width: 200, url: "4.jpg" }
				  { height: 200, width: 200, url: "5.jpg" }
        ]
      }
    }
  ]
})
```

## Changing composite types within `update` and `updateMany`

Composite types can be set, updated or removed within a `update` or `updateMany` method. The following section describes the methods available for updating a single type or multiple types at once, and gives examples of each.

### Changing a single composite type

Use the new `set`, `unset` `update` and `upsert` methods to change a single composite type:

- Use `set` to set a composite type, overriding any existing value
- Use `unset` to unset a composite type. Unlike `set: null`, `unset` removes the field entirely.
- Use `update` to update a composite type
- Use `upsert` to update an existing composite type if it exists, and otherwise create the composite type

For example, use `update` to update a required `shipping address` with an `Address` composite type inside an `Order`:

```ts
const order = await prisma.order.update({
  where: {
    id: 10
  }
  data: {
    shippingAddress: {
      // Update just the zip field
      update: {
        zip: "41232"
      }
    }
  }
})
```

For an optional embedded type, like the `billingAddress`, use `upsert` to create a new record if it does not exist, and update the record if it does:

```ts
const order = await prisma.order.update({
  where: {
    id: 10
  }
  data: {
    billingAddress: {
      // Create the address if it doesn't exist,
      // otherwise update it
      upsert: {
        set: {
          street: "1084 Candycane Lane",
          city: "Silverlake",
          zip: "84323"
        },
        update: {
          zip: "84323"
        }
      }
    }
  }
})
```

You can also use the `unset` method to remove an optional embedded type. The following example uses `unset` to remove the `billingAddress` from an `Order`:

```ts
const order = await prisma.order.update({
  where: {
    id: 10
  }
  data: {
    billingAddress: {
			// Unset the billing address
      // Removes "billingAddress" field from order
      unset: true
    }
  }
})
```

### Changing multiple composite types

Use the new `set`, `push` `updateMany` and `deleteMany` methods to change a list of composite types:

- `set`: Set an embedded list of composite types, overriding any existing list
- `push`: Push values to the end of an embedded list of composite types
- `updateMany`: Update many composite types at once
- `deleteMany`: Delete many composite types at once

For example, use `push` to add a new photo to the `photos` list:

```ts
const product = prisma.product.update({
  where: {
    id: 10,
  },
  data: {
    photos: {
      push: [{ height: 100, width: 200, url: '1.jpg' }],
    },
  },
})
```

Use `updateMany` to update photos with a `url` of `1.jpg` or `2.png`:

```ts
const product = prisma.product.update({
  where: {
    id: 10,
  },
  data: {
    photos: {
      updateMany: {
        where: {
          url: '1.jpg',
        },
        data: {
          url: '2.png',
        },
      },
    },
  },
})
```

The following example uses `deleteMany` to delete all photos with a `height` of 100:

```ts
const product = prisma.product.update({
  where: {
    id: 10,
  },
  data: {
    photos: {
      deleteMany: {
        where: {
          height: 100,
        },
      },
    },
  },
})
```

## Deleting composite types

## Filtering composite types
